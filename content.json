{"pages":[],"posts":[{"title":"关于web安全及一些新的防御方法","text":"前言对于很多刚开始工作的前端而言，web安全似乎是一个说不清道不明的东西。关于web安全，认真学习总结一下，其实就会发现它不难。本文通过面试提问的形式来一一进行总结，希望对于各位小伙伴理解web安全有所帮助。 1.前端有哪些攻击方式？目前常见的web攻击方式主要分为：XSS攻击、CSRF攻击、点击劫持。 2.什么是XSS攻击？XSS攻击有哪几种类型？如何防范XSS攻击？2.1 什么是XSS攻击？XSS(Cross-Site Scripting，跨站脚本攻击)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登录网站时就会执行这些恶意代码。这些脚本可以读取cookie、session tokens或者其他敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。 XSS的本质是：恶意代码未经过滤，与网站正常的代码混在一起，而浏览器是无法辨别哪些脚本是恶意的，导致恶意脚本被执行。由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，利用这些信息冒充用户向网站发起攻击者定义的请求。 举个简单的例子： 12345678910&lt;a href=\"#\" onclick=\"doAttack()\"&gt; click me &lt;script type=\"text/javascript\"&gt; function doAttack() { while (true) { alert('u are under attack'); } } &lt;/script&gt;&lt;/a&gt; 这里在a标签里注入一个脚本，当用户点击后，浏览器会一直弹窗。在真实的网站攻击中，攻击者通过注入的这个脚本，它可以随意干坏事，这样是非常危险的。因为前端你用JavaScript进行的操作，它也一样能，想想是不是觉得很恐怖？ 2.2 XSS攻击有哪几种类型？根据攻击的来源，XSS可以分为存储型(持久型)、反射型(非持久型)、DOM型三种。 反射型XSS 当用户点击一个恶意链接，或者提交一个表单，或者进入一个恶意网站时，注入脚本进入被攻击者的网站。Web服务器将注入一个脚本，比如一个错误信息、搜索结果等，未进行过滤直接返回到用户的浏览器上。 反射型XSS的攻击步骤： 攻击者构造出特殊的url，其中包含恶意代码。 用户打开带有恶意代码的url时，网站服务端将恶意代码从url取出，拼接在HTML中返回给用户。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。注意Chrome 和 Safari 能够检测到 url 上的xss攻击，将网页拦截掉，但是其它浏览器不行，如Firefox。如果不希望被前端拿到cookie，后端可以设置 httpOnly (不过这不是 XSS攻击 的解决方案，只能降低受损范围)。 DOM型XSS DOM 型 XSS 攻击，实际上就是前端 JavaScript 代码不够严谨，把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等。 DOM 型 XSS 的攻击步骤： 攻击者构造出特殊数据，其中包含恶意代码。 用户浏览器执行了恶意代码。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。 存储型XSS 恶意脚本永久存储在目标服务器上。当浏览器请求数据时，脚本从服务器传回并执行，影响范围比反射型和DOM型XSS更大。存储型XSS攻击的原因仍然是没有做好数据过滤：前端提交数据至服务端时，没有做好过滤；服务端在接受到数据时，在存储之前，没有做过滤；前端从服务端请求到数据，没有过滤输出。 存储型 XSS 的攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 2.3 如何防范XSS攻击？2.3.1 防范反射型XSS攻击1234app.get('/welcome', function(req, res) { //对查询参数进行编码，避免反射型 XSS攻击 res.send(`${encodeURIComponent(req.query.type)}`); }); 2.3.2 防范DOM型XSS攻击防范 DOM 型 XSS 攻击的核心就是对输入内容进行转义(DOM 中的内联事件监听器和链接跳转都能把字符串作为代码运行，需要对其内容进行检查)。 对于url链接(例如图片的src属性)，那么直接使用 encodeURIComponent 来转义。 非url，我们可以这样进行编码： 12345678function encodeHtml(str) { if(!str) return ''; return str.replace(/\"/g, '&amp;quot;') .replace(/'/g, '&amp;apos;') .replace(/&lt;/g, '&amp;lt;') .replace(/&gt;/g, '&amp;gt;') .replace(/&amp;/g, '&amp;amp');} 2.3.3 防范存储型XSS攻击 前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况) 服务器接收到数据，在存储到数据库之前，进行转义/过滤 前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤 2.3.4 CSP方式CSP的全称是Content Security Policy，即内容安全策略。 CSP 的主要目标是减少和报告 XSS 攻击 ，XSS 攻击利用了浏览器对于从服务器所获取的内容的信任。恶意脚本在受害者的浏览器中得以运行，因为浏览器信任其内容来源，即使有的时候这些脚本并非来自于它本该来的地方。 CSP通过指定有效域——即浏览器认可的可执行脚本的有效来源——使服务器管理者有能力减少或消除XSS攻击所依赖的载体。一个CSP兼容的浏览器将会仅执行从白名单域获取到的脚本文件，忽略所有的其他脚本 (包括内联脚本和HTML的事件处理属性)。 作为一种终极防护形式，始终不允许执行脚本的站点可以选择全面禁止脚本执行。 如何使用CSP？ 你可以使用 Content-Security-Policy HTTP头部 来指定你的策略，像这样: Content-Security-Policy: policy policy参数是一个包含了各种描述你的CSP策略指令的字符串。 比如一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名)： Content-Security-Policy: default-src ‘self’ 详细的用法可以参考MDN，内容安全策略( CSP ) 3. 什么是CSRF攻击？如何防范？3.1 什么是CSRF攻击？CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 典型的CSRF攻击流程： 受害者登录A站点，并保留了登录凭证（Cookie）。 攻击者诱导受害者访问了站点B。 站点B向站点A发送了一个请求，浏览器会默认携带站点A的Cookie信息。 站点A接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是无辜的受害者发送的请求。 站点A以受害者的名义执行了站点B的请求。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者完成了攻击。 3.2 如何防范CSRF攻击？3.2.1 主流方式 添加验证码(体验不好) 判断请求的来源：检测Referer(并不安全，Referer可以被更改) 使用Token(主流) CSRF攻击之所以能够成功，是因为服务器误把攻击者发送的请求当成了用户自己的请求。那么我们可以要求所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开。跟验证码类似，只是用户无感知。 服务端给用户生成一个token，加密后传递给用户 用户在提交请求时，需要携带这个token 服务端验证token是否正确 3.2.2 启用cookies的SameSite属性SameSite的属性值有3个: strict: Cookie只会在第一方上下文中发送，不会与第三方网站发起的请求一起发送。 lex: Cookies允许与顶级一起发送，并将与第三方网站发起的GET请求一起发送。这是浏览器中的默认值。 none: Cookie将在所有上下文中发送，即允许跨域发送。 注意：以前None是默认值，但最近的浏览器版本将Lax作为默认值，以便对某些类型的跨站点请求伪造（csrf）攻击具有相当强的防御能力。 4. 什么是点击劫持攻击？如何防范？4.1 什么是点击劫持攻击？点击劫持是指在一个Web页面中隐藏了一个透明的iframe，用外层假页面诱导用户点击，实际上是在隐藏的frame上触发了点击事件进行一些用户不知情的操作。 典型的点击劫持攻击流程： 攻击者构建了一个非常有吸引力的网页 将被攻击的页面放置在当前页面的 iframe 中 使用样式将 iframe 叠加到非常有吸引力内容的上方 将iframe设置为100%透明 你被诱导点击了网页内容，你以为你点击的是***，而实际上，你成功被攻击了。 4.2 如何防范点击劫持？4.2.1 frame busting123if (top.location !== window.location) { top.location = window.location;} 需要注意的是: HTML5中iframe的 sandbox 属性、IE中iframe的security 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效。 4.2.2 X-FRAME-OPTIONSX-FRAME-OPTIONS是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。并且在IE8、Firefox3.6、Chrome4以上的版本均能很好的支持。可以设置为以下值: DENY: 拒绝任何域加载 SAMEORIGIN: 允许同源域下加载 ALLOW-FROM: 可以定义允许frame加载的页面地址 5. 总结以上谈到了3种web攻击方式，分别是XSS攻击、CSRF攻击、点击劫持，并给出了具体的防范方式。当然，只有在实践中不断地使用这些技术，才能对web安全有更深刻的认知。","link":"/2020/07/04/%E5%85%B3%E4%BA%8Eweb%E5%AE%89%E5%85%A8%E5%8F%8A%E4%B8%80%E4%BA%9B%E6%96%B0%E7%9A%84%E9%98%B2%E5%BE%A1%E6%96%B9%E6%B3%95/"},{"title":"webpack+vue+ts+koa2前后端合体搭建博客","text":"项目简介博客采用前后端分离，前端用vue+ts+stylus开发，基于MVVM模式；后端用koa2+mysql+sequelize ORM开发，基于MVC模式。前后端由webpack进行合体，并且对webpack进行了生产模式、开发模式分离配置。最终将前端打包的dist和后端的server上传至服务器，前端代码看作是后端的静态资源。 由于之前时间有限，博客的功能只做了登录、注册、写文章、修改文章、修改昵称改头像、关注、评论，感兴趣的同学可以持续添加，比如回复、点赞、分享、分类、标签、推荐等功能。除了功能，样式也可以更改。本来我当初是想仿掘金的，当时时间有限，做了几天就没写了。 博客演示地址 GitHub地址 目录结构123456789101112131415161718192021222324252627282930313233343536373839404142434445blog├─.babelrc├─.dockerignore├─.gitignore├─Dockerfile├─package-lock.json├─package.json├─README.md├─tsconfig.json├─webpack.common.js├─webpack.dev.js├─webpack.prod.js├─static| └defaultAvatar.png├─server| ├─app.ts| ├─router.ts| ├─views| | └index.html| ├─services| | ├─BlogService.ts| | ├─CommentService.ts| | ├─FollowService.ts| | ├─ReplyService.ts| | ├─SortService.ts| | └UserService.ts| ├─public| | ├─dist| ├─models| | ├─BlogModel.ts| | ├─CommentModel.ts| | ├─FollowModel.ts| | ├─ReplyModel.ts| | ├─SortModel.ts| | └UserModel.ts| ├─controllers| | ├─BlogController.ts| | ├─CommentController.ts| | ├─FollowController.ts| | ├─SortController.ts| | └UserController.ts| ├─config| | ├─db.ts| | └tools.ts├─node_modules 1. 初始化项目12npm init -ynpm i webpack webpack-cli --save-dev 2.构建基础架构-安装插件 2.1 实现每次编译前自动清空dist目录，安装clean-webpack-plugin 1npm i clean-webpack-plugin --save-dev 2.2 实现从HTML模板自动生成最终HTML，安装html-webpack-plugin 1npm i html-webpack-plugin --save-dev 2.3 配置typescript环境，安装ts-loader、typescript 1npm i ts-loader typescript --save-dev 2.4 搭建开发环境的热监测服务器，安装webpack-dev-server 1npm i webpack-dev-server --save-dev 2.5 构建项目 12345678910| - client| - node_modules| - server | - public | - views | - index.html.gitignore| - package-lock.json| - package.json| - README.md 3.webpack配置生产环境和开发环境新建三个配置文件，webpack.common.js、webpack.dev.js、webpack.prod.js 3.1 webpack.common.js 123456789101112131415161718192021222324252627282930313233343536373839404142const path = require('path');const webpack = require('webpack');const { CleanWebpackPlugin } = require('clean-webpack-plugin');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = { // 入口 entry: { index: './client/index.ts' }, // 编译输出配置 output: { // js生成到dist/js，[name]表示保留原js文件名，并跟随生成的chunkhash filename: '[name]-[chunkhash:6].js', // 输出到server/public，输出路径为dist，一定要绝对路径 path: path.resolve(__dirname, './server/public/dist') }, // 插件 plugins: [ new CleanWebpackPlugin(), // 设置html模板生成路径 new HtmlWebpackPlugin({ filename: 'index.html', template: './server/views/index.html', chunks: ['index'] }) ], // 配置各个模块规则 module: { rules: [ { test: /\\.ts$/, use: 'ts-loader', exclude: /node_modules/ } ] }, // 配置文件扩展名 resolve: { extensions: ['.ts', '.js', '.vue', '.json'] }} 3.2 webpack.dev.js 12345678910111213const merge = require('webpack-merge');const common = require('./webpack.common');module.exports = merge(common, { // 热监测服务器，动态监测并实时更新页面 devServer: { contentBase: './server/public/dist', // 默认端口为8080 port: 8081, // 开启热更新 hot: true }}); 3.3 webpack.prod.js 1234567const merge = require('webpack-merge');const common = require('./webpack.common');module.exports = merge(common, { // 方便追踪源代码错误 devtool: '#source-map'}); 3.4修改package.json 12345\"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack --config webpack.prod.js --mode production\", \"dev\": \"webpack-dev-server --open chrome --config webpack.dev.js --mode development\"} 4.解决ES6转ES5 4.1 安装babel系列依赖 1npm install babel-loader @babel/core @babel/preset-env --save-dev 1npm install @babel/plugin-transform-runtime @babel/plugin-transform-modules-commonjs --save-dev 1npm install @babel/runtime --save 注意版本兼容：babel-loader8.x对应babel-core7.X，babel-loader7.x对应babel-core6.X 4.2 修改webpack.common.js，这里代码的作用是，在编译时把js文件中ES6转成ES5: 123456789101112131415161718192021module.exports = { module: { rules: [ // 处理ES6转ES5 { test: /\\.js$/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], plugins: [ '@babel/plugin-transform-runtime', '@babel/plugin-transform-modules-commonjs' ] } }, exclude: /node_modules/ } ] }} 5.配置vue开发环境 5.1安装vue-loader、vue、vue-template-compiler、css-loader 1npm i vue-loader vue vue-template-compiler css-loader -S 5.2配置webpack.common.js 1234567891011121314151617const VueLoaderPlugin = require('vue-loader/lib/plugin');module.exports = { module: { rules: [ // 处理vue { test: /\\.vue$/, use: 'vue-loader' } ] }, plugins: [ // vue-loader必须和VueLoaderPlugin一起使用，否则报错 new VueLoaderPlugin() ]} 除此之外，在入口文件里引入.vue文件，会出现红色下划线，这是因为没有声明。因此新建types文件夹，在里面新建vue.d.ts: 1234declare module \"*.vue\" { import Vue from \"vue\"; export default Vue;} 因为本项目用typescript开发，即使做出了vue的导入导出声明，也还是会提示找不到App.vue文件。因此在项目根目录下新建tsconfig.json文件： 123456789{ \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"sourceMap\": true }, \"include\": [\"client\", \"server\"], \"exclude\": [\"node_modules\"]} 5.3记一次坑 启动webpack报如下错误： 123ERROR in chunk index [entry][name]-[chunkhash:6].jsCannot use [chunkhash] or [contenthash] for chunk in '[name]-[chunkhash:6].js' (use [hash] instead) 这是因为在配置webpack输出filename时这么写的，因此直接使用hash即可。 6.在vue里使用stylus 6.1安装依赖包 1npm install style-loader --save-dev 1npm install stylus-loader stylus --save-dev 6.2在webpack.common.js里配置 12345678910111213141516module.exports = { module: { rules: [ // 处理CSS(类似管道，优先使用css-loader处理，最后是style-loader) { test: /\\.css$/, use: ['style-loader', 'css-loader'] }, // 处理stylus { test: /\\.styl(us)$/, use: ['style-loader', 'css-loader', 'stylus-loader'] } ] }} 注意，每次修改了webpack记得重启项目。 6.3现在我们想把样式通过link方式引入 先安装MiniCssExtractPlugin: 1npm i mini-css-extract-plugin --save-dev 再修改webpack.common.js，将style-loader替换掉: 123456789101112131415161718192021222324252627const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = { plugins: [ ...... // 将样式抽离使用link方式引入 new MiniCssExtractPlugin({ filename: '[name]-[hash:6].css' }) ], // 配置各个模块规则 module: { rules: [ ...... // 处理CSS(类似管道，优先使用css-loader处理，最后是style-loader) { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, 'css-loader'] }, // 处理stylus { test: /\\.styl(us)$/, use: [MiniCssExtractPlugin.loader, 'css-loader', 'stylus-loader'] } ] }} 7.处理图片资源 7.1安装插件file-loader和url-loader，url-loader基于file-loader，所以两个都要安装。 (也可以只使用file-loader，url-loader在file-loader的基础上扩展了功能，比如能设置小于多少KB的图片进行base64转码等） 1npm install file-loader url-loader --save-dev 7.2配置webpack.common.js 1234567891011121314151617module.exports = { module: { rules: [ // 处理图片 { test: /\\.(png|jpg|gif|eot|woff|ttf|svg|webp|PNG)$/, loader: 'url-loader', options: { name: '[name]-[hash:6].[ext]', esModule: false, // 否则图片加载src显示为object module limit: 10240, // 小于10kb的特殊处理，转成base64 }, exclude: /node_modules/ } ] }} 8.前端开启GZIP压缩gzip就是GNUzip的缩写，是一个文件压缩程序，可以将文件压缩进后缀为.gz的压缩包。而我们前端所讲的gzip压缩优化，就是通过gzip这个压缩程序，对资源进行压缩，从而降低请求资源的文件大小。**gzip压缩能力很强，压缩力度可达到70%。 8.1安装compression-webpack-plugin 1npm i compression-webpack-plugin -D 8.2在webpack.common.js里配置 1234567891011const CompressionWebpackPlugin = require('compression-webpack-plugin');module.exports = { plugins: [ ...... new CompressionWebpackPlugin({ test: /\\.(js|css)$/, threshold: 10240 // 这里对大于10k的js和css文件进行压缩 }) ]} 注意事项：compression-webpack-plugin使用会受版本影响，版本过高会冲突报错。解决方案：重新安装较低版本的包 9.使用At-UIAT-UI 是一款基于 Vue.js 2.0 的前端 UI 组件库，主要用于快速开发 PC 网站中后台产品. 9.1 安装 1npm i at-ui -S 由于at-ui的样式已经独立成一个项目了，因此这里可以npm安装at-ui-style。本人这里直接使用的CDN方式引入以减小开销。 9.2打包运行后报错 1234ERROR in ./node_modules/element-ui/lib/theme-chalk/index.cssModule build failed (from ./node_modules/mini-css-extract-plugin/dist/loader.js):ModuleParseError: Module parse failed: Unexpected character ' ' (1:0)You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders 解决：将url-loader替换为file-loader 123456789101112// 处理图片 { test: /\\.(png|jpg|gif|eot|woff|ttf|svg|webp|PNG)(\\?\\S*)?$/, loader: 'file-loader' // options: { // name: '[name]-[hash:6].[ext]', // esModule: false, // 否则图片加载src显示为object module // limit: 10240, // 小于10kb的特殊处理，转成base64 // puplicPath: './server/public' // }, // exclude: /node_modules/ } 10.制作导航栏 10.1登录或者注册时隐藏导航栏 1&lt;header v-if=\"$route.name !== 'register'\"&gt;&lt;header-section&gt;&lt;/header-section&gt;&lt;/header&gt; 10.2用bcrypt存储的密码，一定要设置足够的长度，否则会一直返回false。 11.登录token校验 11.1安装依赖 12npm i jsonwebtoken --savenpm i koa-jwt --save 11.2TS2304: Cannot find name ‘localStorage’ 配置tsconfig.json 12345678910{ \"compilerOptions\": { \"target\": \"es5\", \"module\": \"commonjs\", \"sourceMap\": true, \"lib\": [\"DOM\", \"ES2016\", \"ES2015\"] }, \"include\": [\"client\", \"server\"], \"exclude\": [\"node_modules\"]} 11.3鉴权中间件一定放在路由的前面。 123456789101112131415// 错误处理app.use(async (ctx, next) =&gt; { return next().catch(err =&gt; { if(err.status === 401) { ctx.status = 401; ctx.body = 'Protected resource, use Authorization header to get access\\n'; } else { throw err; } })});// unless表示不对登录注册做token校验(颁发token时密钥是secret)app.use(koajwt({ secret: 'secret' }).unless({ path: [/^\\/login/, /^\\/register/] }));app.use(bodyParser());router(app); 前端axios拦截器添加token一定要这样写，否则koa-jwt怎么都不会解析成功！切记！切记！这里我找了一下午的坑~~ 1234let token = JSON.parse(localStorage.getItem('token')); if(token) { config.headers.common['Authorization'] = 'Bearer ' + token; } 12.main组件里登录操作，成功后header里导航栏用户信息不刷新 12.1vuex结合localStorage 123456789101112131415161718192021222324252627282930313233import Vuex from 'vuex';import Vue from 'vue';Vue.use(Vuex);const store = new Vuex.Store({ state: { user: JSON.parse(localStorage.getItem('user')) || null, token: JSON.parse(localStorage.getItem('token')) || '' }, getters: { getUser: state =&gt; state.user, getToken: state =&gt; state.token }, mutations: { setUser(state, payload) { state.user = payload.user; // 数据持久化 localStorage.setItem('user', JSON.stringify(payload.user)); }, setToken(state, payload) { state.token = payload.token; localStorage.setItem('token', JSON.stringify(payload.token)); }, logout(state) { localStorage.removeItem('user'); localStorage.removeItem('token'); state.user = null; state.token = ''; } }});export default store; 12.2登录组件登录成功后调用 123// 存储用户信息this.$store.commit('setUser', { user: res.data.user });this.$store.commit('setToken', { token: res.data.token }); 12.2登出时调用 1234logout() { this.$store.commit('logout'); window.location.reload();} 在这里vuex更新导航栏没刷新，我就加了reload手动刷新，由于时间有限具体原因留到后面再分析。 12.3鉴权失败调用(比如token过期了浏览器清除登录信息) 12345678this.axios.get('/sort').then(res =&gt; { this.sorts = res.data;}, err =&gt; { if(err.code === -1) { // token鉴权失败 this.$store.commit('logout'); this.$router.push({ name: 'home' }); }}) 综上，vuex结合localStorage能够实现用户登录时保存信息。vuex 中store的数据需要放到computed 里面才能同步更新视图，切记切记！找了一天的bug，试了n多种方法，才找到是这个原因~~贴个链接https://blog.csdn.net/wangshang1320/article/details/98871252 13.vue中使用input和label实现上传按钮美化 13.1 123456&lt;div class=&quot;img-modify&quot;&gt; &lt;label for=&quot;input-img&quot;&gt; &lt;at-button type=&quot;primary&quot;&gt;点击上传&lt;/at-button&gt; &lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;input-img&quot; @change=&quot;fileHandler($event)&quot; accept=&quot;image/*&quot;&gt;&lt;/div&gt; 12345678.img-modify flex 9; label position absolute; input opacity 0; width 82px; height 31.6px; 13.2获取file对象 123 fileHandler(e) { let file = e.target.files[0];} 14.前端获取所有关注者的博客，批量处理异步操作 14.1问题描述 当我关注了几个博主时，点击导航栏的关注，要获取他们的所有文章。刚开始我是在for循环里操作，但是这样很明显有一个问题，因为for循环是同步代码，我永远只能拿到最后一个请求的结果，所以需要解决这个问题。 14.2解决 因为我使用的是axios，axios本身封装了promise，而且axios提供了一个all方法批量处理异步请求结果，非常方便。首先定义一个返回的promise数组，暂且命名为promiseAll。然后拿到所有·异步结果后，通过调用axios提供的all方法批量处理回调函数里的结果。具体代码如下： 123456789101112131415161718192021// 获取关注者的所有博文getFollowersBlogs() { // 先返回所有异步请求结果 let promiseAll = this.followerList.map((item) =&gt; { return this.axios.get('/blog/email/' + item.follow_email); }); // 再处理所有回调结果 this.axios.all(promiseAll).then(resArr =&gt; { resArr.forEach(res =&gt; { this.blogList = this.blogList.concat(res.data); }); }, err =&gt; { if(err.code === -1) { // token鉴权失败 this.$Modal.info({ content: '登录过期,请重新登录!' }); this.$store.commit('logout'); this.$router.push({ name: 'login' }); } });} 15.博客待完善功能 首页分页✔ 评论✔ 删除文章 编辑文章必须修改内容才生效的问题✔ 点赞 搜索页-对题目高亮✔ 前端url加密。vue里用params传参呢，怕刷新页面参数丢失。用query呢，参数直接显示在地址栏。因此这里考虑对query加密处理。网上搜索到一种方法，用到的是base64加密。✔ 反馈 登录注册及搜索支持按键enter✔ 密码修改 16.前端对url进行base64加密 16.1安装js-base64 1npm install --save js-base64 16.2在ES6+中使用，这里将挂载到vue实例上，以供全局使用 123// 引入js-base64对url加密import { Base64 } from 'js-base64';Vue.prototype.$Base64 = Base64; 对参数加密： 1234this.$router.push({ name: 'search', query: { keyword: this.$Base64.encode(this.searchValue) } }); 对参数解密： 1this.keyword = this.$Base64.decode(this.$route.query.keyword); 17.axios的get请求像post那样传递参数 17.1get请求时的写法 12345678910this.axios.get('/blogs/list', { params: { pageSize: this.page.pageSize, currentPage: this.page.currentPage }}).then(res =&gt; { this.blogList = res.data;}, err =&gt; { console.error(err);}); 17.2获取参数 12let pageSize = Number(ctx.request.query.pageSize), currentPage = Number(ctx.request.query.currentPage); 注意数据库查询前参数转为整型，否则会报错。 18.监听登录和注册密码框enter事件实现登录注册 监听最后一个输入框回车事件 12&lt;at-input v-model=\"checkPass\" type=\"password\" placeholder=\"请确认密码\" size=\"large\" :maxlength=\"12\" :minlength=\"6\" @keyup.enter.native=\"register\"&gt;&lt;/at-input&gt; 19.评论 19.1页面点击文本域显示评论按钮 记一次vuex获取用户信息的坑。 因为vuex存储的是user和token，在vue中使用的时候，必须使用计算属性，否则会报错。另外，当退出登录时，因为user和token都已经被删除，所以使用头像等时格外注意判断。 123456789101112avatar: function() { if(this.$store.getters.getUser !== null) { return this.$store.getters.getUser.avatar; } return null;},user: function() { if(this.$store.getters.getUser !== null) { return this.$store.getters.getUser; } return null;} 19.2获取博客评论需要获取用户名、头像，因此用户表和评论表需要关联 123// 用户与评论是一对多关系UserModel2.hasMany(CommentModel);CommentModel.belongsTo(UserModel2, { foreignKry: 'email' }); 123456789101112// 获取博客评论(要返回用户头像和用户名，需关联表，建立一对多关系)findBlogComments: async (blog_id) =&gt; { return await CommentModel.findAll({ where: { blog_id }, include: [{ model: UserModel2, attributes: ['username', 'avatar'] }] })} 上述查询语句会报错： SequelizeDatabaseError: Unknown column ‘comment.userEmail’ in ‘field list’ 注释掉关联声明： 123// 用户与评论是一对多关系// UserModel2.hasMany(CommentModel);CommentModel.belongsTo(UserModel2, { foreignKey: 'email', targetKey: 'email' }); 一个模型要关联另一个模型时，加一句声明即可，否则会报错。 注意点： type 如果不存在则直接用字符串表示 如：’TIMESTAMP’; 如果需要在更新表字段时记录更新时间，可应使用 updateAt，并设置默认值和对应的字段名。 如果默认值不是具体的数值，可以用 literal 函数去表示。 tableName 表名，u 为别名。 建立关联关系时，如果外键关联的是主键则不用写 targetKey，否则需要。 20.总结这个博客我当时花了4天时间搭建起来，主要是为了巩固webpack各种配置，以及学习typescript的使用(虽然并没有怎么用ts语法)。整个过程对于自己掌握项目快速搭建很有帮助，希望和我入门前端不久的小伙伴们能够通过这个过程学会webpack的使用。","link":"/2020/07/05/webpack-vue-ts-koa2%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%88%E4%BD%93%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"}],"tags":[{"name":"web安全","slug":"web安全","link":"/tags/web%E5%AE%89%E5%85%A8/"},{"name":"webpack; vue; koa2; typescript","slug":"webpack-vue-koa2-typescript","link":"/tags/webpack-vue-koa2-typescript/"}],"categories":[{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"}]}